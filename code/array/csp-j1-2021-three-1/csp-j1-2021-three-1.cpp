// Josephus问题
// 问题描述：
// 有 n 个人围成一个圆圈，依次编号为 0 至 n-1。
// 从编号为 0 的人开始，依次按照顺时针方向报数，报到 m 的人将被移出圈外，
// 然后再从下一个人开始继续报数，直到只剩下最后一个人。

#include <iostream>

using namespace std;

const int MAXN = 1000000; // 最大的人数
int F[MAXN]; // 标记每个人是否被淘汰出圈

int main(){
	int n;
	cin >> n; // 接收输入的人数n
	int i = 0,p = 0,c = 0; // 当前报数的人编号、报数的标记、以及已经被淘汰的人数
	while(c < n - 1){ // 进入一个while循环，循环条件是还未剩下最后一个人
		if(F[i] == 0){ // 判断当前报数的人是否还在圈内，如果F[i]为0，表示该人还在圈内
			if(p){// 判断当前报数标记p的值。p的初始值为0，当p为1时，说明报数到1i，该人将被淘汰
				F[i] = 1; // 将当前报数的人标记为1，表示被淘汰
				c++; // 然后c增加1，表示已经淘汰的人数加1 
			} 
			p^=1; // 将p的值进行异或运算，相当于p取反，即0变成1，1变成0。这样可以实现交替报数的效果
		}
		i = (i + 1) % n; // 更新报数的人的编号i，取余操作确保编号在圈内循环
	}
	int ans = -1; // 定义一个变量ans，用于记录最后剩下的人的编号，初始化为-1
	for(i = 0;i < n;i++) // 遍历数组F，查找最后剩下的人的编号
		if(F[i] == 0) // 如果F[i]为0，表示该人未被淘汰
			ans = i; // 将该人的编号赋值给ans
	cout << ans << endl;
	return 0;
}
