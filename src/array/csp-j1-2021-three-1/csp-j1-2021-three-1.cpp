// （Josephus 问题）有 𝑛 个人围成一个圈，依次标号 0 至 𝑛 − 1。
// 从 0 号开始，依次 0, 1, 0, 1, … 交替报数，报到 1 的人会离开，直至圈中只剩下一个人。
// 求最后剩下人的编号。

// 求解方法：
// 解决Josephus问题的经典方法是使用递归或数学公式。
// 可以得到一个递推关系式，用 f(n,m) 表示 n 个人报数，报到 m 时最后剩下的人的编号。
// 递推关系式为：
// f(n,m) = (f(n-1,m) + m) % n
// 其中，f(1,m) = 0，表示只剩下一个人时的情况。
// 这个关系式的意义是：在 n 个人报数的情况下，
// 第一轮报数时，第一个被淘汰的人的编号为 (f(n-1,m) + m) % n。
// 然后问题转化为 n-1 个人报数的情况，并从下一个人开始重新报数。
// 通过不断递归计算 f(n,m)，最终可以得到只剩下最后一个人的编号，即 Josephus 问题的解。

#include <iostream>

using namespace std;

const int MAXN = 1000000; // 最大的人数
int F[MAXN]; // 标记每个人是否被淘汰出圈

int main(){
	int n;
	cin >> n; // 接收输入的人数n
	int i = 0,p = 0,c = 0; // 当前报数的人编号、报数的标记、以及已经被淘汰的人数
	while(c < n - 1){ // 进入一个while循环，循环条件是还未剩下最后一个人
		if(F[i] == 0){ // 判断当前报数的人是否还在圈内，如果F[i]为0，表示该人还在圈内
			if(p){// 判断当前报数标记p的值。p的初始值为0，当p为1时，说明报数到1i，该人将被淘汰
				F[i] = 1; // 将当前报数的人标记为1，表示被淘汰
				c++; // 然后c增加1，表示已经淘汰的人数加1 
			} 
			p^=1; // 将p的值进行异或运算，相当于p取反，即0变成1，1变成0。这样可以实现交替报数的效果
		}
		i = (i + 1) % n; // 更新报数的人的编号i，取余操作确保编号在圈内循环
	}
	int ans = -1; // 定义一个变量ans，用于记录最后剩下的人的编号，初始化为-1
	for(i = 0;i < n;i++) // 遍历数组F，查找最后剩下的人的编号
		if(F[i] == 0) // 如果F[i]为0，表示该人未被淘汰
			ans = i; // 将该人的编号赋值给ans
	cout << ans << endl;
	return 0;
}
